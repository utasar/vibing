.ORIG x3000

; main's return address
LD R6, STACK_BOTTOM			; R6 = x6000
STR R7, R6, #0

; previous frame pointer
ADD R6, R6, #-1				; R6 = x5FFF
STR R5, R6, #0
ADD R5, R6, #0				; R5 = x5FFF

; save R0
ADD R6, R6, #-1				; R6 = x5FFE
STR R0, R6, #0

; save R1
ADD R6, R6, #-1				; R6 = x5FFD
STR R1, R6, #0

; initialize int x
ADD R6, R6, #-1				; R6 = x5FFC
LD R0, INIT_X				; R0 = INIT_X = #10
STR R0, R6, #0

; initialize int y
ADD R6, R6, #-1				; R6 = x5FFB
LD R0, INIT_Y				; R0 = INIT_Y = #11
STR R0, R6, #0

; declare int val
ADD R6, R6, #-1				; R6 = x5FFA

; pass argument x + 10 to max()
ADD R6, R6, #-1				; R6 = x5FF9
LDR R0, R5, #-3				; R0 = int x = #10
ADD R0, R0, #10				; R0 = x + 10
STR R0, R6, #0

; pass argument y to max()
ADD R6, R6, #-1				; R6 = x5FF8
LDR R0, R5, #-4				; R0 = int y = #11
STR R0, R6, #0

JSR MAX
STR R0, R5, #-5				; val = max(x + 10, y);

; pop int b and int a
ADD R6, R6, #2				; R6 = x5FFA

HALT

STACK_BOTTOM .FILL x6000
INIT_X .FILL #10
INIT_Y .FILL #11

MAX
; max's return address
ADD R6, R6, #-1				; R6 = x5FF7
STR R7, R6, #0

; previous frame pointer
ADD R6, R6, #-1				; R6 = x5FF6
STR R5, R6, #0
ADD R5, R6, #0				; R5 = x5FF6

; save R0
ADD R6, R6, #-1				; R6 = x5FF5
STR R0, R6, #0

; save R1
ADD R6, R6, #-1				; R6 = x5FF4
STR R1, R6, #0

; initialize int result
ADD R6, R6, #-1				; R6 = x5FF3
LDR R0, R5, #3				; R0 = int a
STR R0, R6, #0

LDR R1, R5, #2				; R1 = int b
NOT R1, R1
ADD R1, R1, #1				; R1 = -b
ADD R1, R0, R1				; R1 = a - b
BRzp RETURN
; if (b > a)
; result = b
LDR R1, R5, #2				; R1 = b
STR R1, R5, #-3

RETURN
LDR R0, R5, #-3				; R0 = result

; pop int result
ADD R6, R6, #1				; R6 = x5FF4

; pop R1
LDR R1, R6, #0
ADD R6, R6, #1				; R6 = x5FF5

; pop R0
ADD R6, R6, #1				; R6 = x5FF6

; pop previous frame pointer (R5)
LDR R5, R6, #0
ADD R6, R6, #1				; R6 = x5FF7

; pop max's return address (R7)
LDR R7, R6, #0
ADD R6, R6, #1				; R6 = x5FF8

RET

.END
